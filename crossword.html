<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Labyrinth Hotel - Final Cipher (Fix v2)</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Noto+Serif+KR:wght@400;700&family=Space+Mono&display=swap" rel="stylesheet">
    <script>
    // 1. 마우스 우클릭 차단
    document.addEventListener('contextmenu', function(e) {
        e.preventDefault();
    }, false);

    // 2. 단축키 차단 (F12, 소스보기, 개발자 도구)
    document.addEventListener('keydown', function(e) {
        // F12 막기
        if (e.key === "F12") {
            e.preventDefault();
        }
        // Ctrl+U (소스 보기) 막기
        if (e.ctrlKey && e.key === 'u') {
            e.preventDefault();
        }
        // Ctrl+Shift+I / Ctrl+Shift+J (개발자 도구) 막기
        if (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'i' || e.key === 'J' || e.key === 'j')) {
            e.preventDefault();
        }
        // Ctrl+S (저장) 막기
        if (e.ctrlKey && e.key === 's') {
            e.preventDefault();
        }
    }, false);
</script>
    <style>
    
@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Cormorant+Garamond:ital,wght@0,600;1,500&family=Noto+Serif+KR:wght@300;600&family=Space+Mono&display=swap');
    <html lang="ko">
.hotel-support-banner {
  text-align: center;
  margin-bottom: 20px;
}

.gold-border {
  display: inline-block;
  padding: 8px 16px;
  color: #b8b4b0; /* 빛바랜 금색 */
  text-decoration: none;
  font-family: 'Noto Serif KR', serif;
  font-size: 0.9rem;
  border: 1px solid #5a5550;
  background: rgba(20, 20, 20, 0.8); /* 어두운 배경 */
  letter-spacing: 0.5px;
  transition: all 0.3s ease;
}

.gold-border:hover {
  background: #8c8883;
  color: #1a1a1a;
  box-shadow: 0 0 10px rgba(197, 160, 89, 0.4);
}

.gold-border .icon {
  margin-right: 5px;
  font-size: 0.8rem;
}
        :root {
            --bg-main: #1a1a1b;
            --silver-dark: #7a7a7a;
            --silver-mid: #b0b0b0;
            --silver-bright: #e0e0e0;
            --cell-active: #2d2d2e;
            --metal-border: #4a4a4b;
            --correct-bg: #d1d1d1;
            --correct-text: #0a0a0a;
            --highlight-pink: rgba(255, 182, 193, 0.5);
        }

        body {
            background-color: var(--bg-main);
            color: var(--silver-bright);
            font-family: 'Noto Serif KR', serif;
            margin: 0; padding: 40px 10px;
            display: flex; flex-direction: column; align-items: center;
        }

        h1 {
            font-family: 'Cinzel', serif;
            font-size: 2.5rem; letter-spacing: 12px;
            background: linear-gradient(to bottom, var(--silver-bright), var(--silver-dark));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            margin-bottom: 50px; text-align: center;
        }

        .grid-frame {
            display: grid;
            grid-template-columns: repeat(25, 40px);
            grid-template-rows: repeat(20, 40px);
            gap: 2px; background-color: var(--metal-border);
            padding: 10px; border: 4px solid var(--silver-dark);
            box-shadow: 0 40px 80px rgba(0,0,0,0.6);
        }

        .cell {
            width: 40px; height: 40px;
            background-color: transparent;
            display: flex; align-items: center; justify-content: center;
            position: relative;
        }

        .cell.active { background-color: var(--cell-active); cursor: pointer; }
        .cell.active:hover { background-color: #3d3d3f; }

        .index {
            position: absolute; top: 1px; left: 3px;
            font-size: 1rem; color: var(--silver-mid); font-weight: bold;
        }

        .letter {
            font-family: 'Space Mono', monospace;
            font-size: 1.3rem; font-weight: bold;
            opacity: 0; transition: opacity 0.4s ease;
        }

        .cell.revealed { background: var(--correct-bg) !important; }
        .cell.revealed .letter { opacity: 1; color: var(--correct-text); }

        .cell.special-highlight {
            background-color: var(--highlight-pink) !important;
            box-shadow: inset 0 0 8px rgba(255,192,203,0.5);
        }

        .clues-wrapper {
            margin-top: 40px; display: grid; grid-template-columns: 1fr 1fr;
            gap: 50px; width: 100%; max-width: 950px;
            background: rgba(255,255,255,0.03); padding: 30px;
        }
        .clue-group h2 { font-family: 'Cinzel', serif; border-bottom: 2px solid var(--silver-dark); padding-bottom: 10px; }
        .clue-item { margin: 12px 0; font-size: 0.95rem; color: #ccc; }
        /* 리셋 버튼 스타일 */
    .control-panel {
        margin-top: 30px;
        margin-bottom: 20px;
    }

    .hotel-btn {
        background: transparent;
        color: #8c8883;
        border: 1px solid #5a5550;
        padding: 10px 25px;
        font-family: 'Cinzel', serif;
        cursor: pointer;
        letter-spacing: 2px;
        transition: all 0.4s ease;
        font-size: 0.8rem;
    }

    .hotel-btn:hover {
        background: #c5a059;
        color: #1a1a1a;
        box-shadow: 0 0 15px rgba(197, 160, 89, 0.3);
    }
    </style>
</head>
<body>

    <h1>Labyrinth Hotel</h1>

    <div class="grid-frame" id="grid"></div>
<div class="control-panel">
    <button onclick="resetGrid()" class="hotel-btn">RESEAL THE PUZZLE (전체 초기화)</button>
</div>
    <div class="clues-wrapper">
        <div class="clue-group">
            <h2>Across</h2>
            <div class="clue-item">2. </div>
            <div class="clue-item">3. </div>
            <div class="clue-item">4. </div>
            <div class="clue-item">5. </div>
            <div class="clue-item">6. </div>
            <div class="clue-item">7. </div>
        </div>
        <div class="clue-group">
            <h2>Down</h2>
            <div class="clue-item">2. </div>
            <div class="clue-item">3. </div>
            <div class="clue-item">4. </div>
            <div class="clue-item">5. </div>
            <div class="clue-item">6. </div>
            <div class="clue-item">7. </div>
        </div>
    </div>

    <script>
    // 정답 단어를 삭제하고 위치와 길이 정보만 남김
    const puzzleWords = [
        // Across
        { r: 2, c: 0, dir: 'A', id: '2', len: 15 },
        { r: 3, c: 5, dir: 'A', id: '3', len: 9 },
        { r: 5, c: 9, dir: 'A', id: '7', len: 12 },
        { r: 6, c: 9, dir: 'A', id: '6', len: 13 },
        { r: 9, c: 7, dir: 'A', id: '4', len: 12 },
        { r: 10, c: 9, dir: 'A', id: '5', len: 13 },
        
        // Down
        { r: 0, c: 0, dir: 'D', id: '4', len: 12 },
        { r: 1, c: 2, dir: 'D', id: '7', len: 13 },
        { r: 1, c: 5, dir: 'D', id: '6', len: 12 },
        { r: 0, c: 10, dir: 'D', id: '5', len: 12 },
        { r: 10, c: 12, dir: 'D', id: '2', len: 10 },
        { r: 10, c: 20, dir: 'D', id: '3', len: 10 }
    ];

    const highlightCoords = ["0-0", "7-2", "10-2", "7-5", "5-9", "3-10", "10-13", "6-17", "10-20"];
    const gridElement = document.getElementById('grid');
    const cellMap = {};

    // 그리드 맵 생성 (글자 데이터 없이 구조만 생성)
    puzzleWords.forEach(wordData => {
        for (let i = 0; i < wordData.len; i++) {
            const r = wordData.dir === 'A' ? wordData.r : wordData.r + i;
            const c = wordData.dir === 'A' ? wordData.c + i : wordData.c;
            const key = `${r}-${c}`;
            if (!cellMap[key]) cellMap[key] = { indices: [], words: [] };
            if (i === 0) cellMap[key].indices.push(wordData.id);
            cellMap[key].words.push(wordData);
        }
    });

    // 그리드 그리기
    for (let r = 0; r < 20; r++) {
        for (let c = 0; c < 25; c++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            const key = `${r}-${c}`;
            const data = cellMap[key];

            if (highlightCoords.includes(key)) cell.classList.add('special-highlight');

            if (data) {
                cell.classList.add('active');
                cell.id = `cell-${r}-${c}`;
                if (data.indices.length > 0) {
                    const idx = document.createElement('span');
                    idx.className = 'index';
                    idx.textContent = data.indices[0];
                    cell.appendChild(idx);
                }
                // 글자를 담을 공간만 생성 (비어있음)
                const letter = document.createElement('span');
                letter.className = 'letter';
                cell.appendChild(letter);

                cell.onclick = () => {
                    const input = prompt(`단어를 입력하세요 (길이: ${data.words[0].len}):`);
                    if (!input) return;
                    
                    const upperInput = input.trim().toUpperCase();
                    // 클릭한 칸이 포함된 모든 단어 선 중, 입력 길이와 맞는 것을 찾아 채움
                    const targetWord = data.words.find(w => w.len === upperInput.length);
                    
                    if (targetWord) {
                        fillWord(targetWord, upperInput);
                    } else {
                        alert(`길이가 맞지 않습니다. (필요 길이: ${data.words[0].len})`);
                    }
                };
            }
            gridElement.appendChild(cell);
        }
    }

    // 유저가 입력한 글자를 그대로 그리드에 박아넣는 함수
    function fillWord(w, text) {
        for (let i = 0; i < w.len; i++) {
            const r = w.dir === 'A' ? w.r : w.r + i;
            const c = w.dir === 'A' ? w.c + i : w.c;
            const target = document.getElementById(`cell-${r}-${c}`);
            if (target) {
                target.classList.add('revealed');
                target.querySelector('.letter').textContent = text[i];
            }
        }
    }
    // ... (이전 puzzleWords, highlightCoords 설정 동일) ...

    function drawGrid() {
        gridElement.innerHTML = ''; // 초기화 후 다시 그리기 위해
        for (let r = 0; r < 20; r++) {
            for (let c = 0; c < 25; c++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                const key = `${r}-${c}`;
                const data = cellMap[key];

                if (highlightCoords.includes(key)) cell.classList.add('special-highlight');

                if (data) {
                    cell.classList.add('active');
                    cell.id = `cell-${r}-${c}`;
                    if (data.indices.length > 0) {
                        const idx = document.createElement('span');
                        idx.className = 'index';
                        idx.textContent = data.indices[0];
                        cell.appendChild(idx);
                    }
                    const letter = document.createElement('span');
                    letter.className = 'letter';
                    cell.appendChild(letter);

                    cell.onclick = () => {
                        // 현재 입력된 글자가 있다면 보여주기
                        const currentText = cell.querySelector('.letter').textContent;
                        const msg = currentText 
                            ? `현재 글자: "${currentText}"\n새 단어를 입력하거나, 비우고 확인을 누르면 지워집니다.`
                            : `단어를 입력하세요 (길이: ${data.words[0].len}):`;
                            
                        const input = prompt(msg, currentText);
                        
                        // 취소를 누른 경우(null)는 아무 작업 안 함
                        if (input === null) return;
                        
                        const upperInput = input.trim().toUpperCase();
                        
                        // 아무것도 입력하지 않고 확인을 누르면 해당 영역 삭제
                        if (upperInput === "") {
                            clearWord(data.words[0]);
                            return;
                        }

                        // 길이 체크 및 채우기
                        const targetWord = data.words.find(w => w.len === upperInput.length);
                        if (targetWord) {
                            fillWord(targetWord, upperInput);
                        } else {
                            alert(`길이가 맞지 않습니다. (필요 길이: ${data.words[0].len})`);
                        }
                    };
                }
                gridElement.appendChild(cell);
            }
        }
    }

    // 단어 영역을 지우는 함수
    function clearWord(w) {
        for (let i = 0; i < w.len; i++) {
            const r = w.dir === 'A' ? w.r : w.r + i;
            const c = w.dir === 'A' ? w.c + i : w.c;
            const target = document.getElementById(`cell-${r}-${c}`);
            if (target) {
                target.classList.remove('revealed');
                target.querySelector('.letter').textContent = '';
            }
        }
    }

    // 전체 그리드를 리셋하는 함수
    function resetGrid() {
        if (confirm("입력한 글자들을 모두 초기화하겠습니까?")) {
            const revealedCells = document.querySelectorAll('.cell.revealed');
            revealedCells.forEach(cell => {
                cell.classList.remove('revealed');
                cell.querySelector('.letter').textContent = '';
            });
        }
    }

    // 초기 실행
    drawGrid();
</script>
</body>
</html>
